.386
.model flat, stdcall
include irvine32.inc
ARRAY_MAX_SIZE = 200
sortArray PROTO arrAddr : DWORD, arrLength : DWORD
.stack 4096
.data
arr DWORD ARRAY_MAX_SIZE DUP(0)
arrSizeByUserInput DWORD 0

str1 BYTE "请输入排序的数组长度： ", 0
str2 BYTE "你输入的数组长度大于200！", 0
str3 BYTE "请输入需要排序的数据: ", 0
str4 BYTE "你需要的数据已经输入完毕", 0
str5 BYTE "排序之后的数组：", 0
.code
main PROC
CALL recvArraySize
MOV arrSizeByUserInput, EAX
mov esi, offset arr
mov ecx, arrSizeByUserInput
CALL recvArrayData

INVOKE sortArray, ADDR arr, arrSizeByUserInput

INVOKE ExitProcess, 0
main ENDP


sortArray PROC arrAddr : DWORD, arrLength : DWORD
mov esi, arrAddr
mov ecx, arrLength
dec ecx
L3 :
push ecx
mov edi, 0

L2 : mov eax, [esi + edi * type DWORD]
cmp eax, [esi + edi * type DWORD + 4]
jle L1
; xchg交换
xchg eax, [esi + edi * type DWORD + 4]
mov[esi + edi * type DWORD], eax

L1 : inc edi
loop L2
pop ecx
loop L3

mov edx, offset str5
call WriteString
call crlf

mov esi, arrAddr
mov ecx, arrLength
mov edi, 0

L4: mov eax, [esi + edi * 4]
call WriteInt
call crlf
inc edi
loop L4

ret
sortArray ENDP

recvArraySize PROC
mov edx, offset str1
call WriteString
call ReadInt
cmp eax, 200
JA L1
ret
L1 : mov edx, offset str2
call WriteString
EXIT
recvArraySize ENDP

recvArrayData PROC USES ESI ECX
mov edx, offset str3
L1 : call WriteString
xor eax, eax

call ReadInt
mov[esi], eax
add esi, type DWORD
loop L1

RET
recvArrayData ENDP

end main