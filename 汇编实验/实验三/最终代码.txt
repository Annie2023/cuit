.386
.model flat, stdcall
include irvine32.inc
ARRAY_MAX_SIZE = 200
sortArray PROTO arrAddr : DWORD, arrLength : DWORD
searchIntInArrayIndex PROTO arrAddr : DWORD, arrLength : DWORD
.stack 4096
.data
arr DWORD ARRAY_MAX_SIZE DUP(0)
arrSizeByUserInput DWORD 0
arrIndexBinary BYTE 33 DUP(0)

str1 BYTE "请输入排序的数组长度： ", 0
str2 BYTE "你输入的数组长度大于200！", 0
str3 BYTE "请输入需要排序的数据: ", 0
str4 BYTE "你需要的数据已经输入完毕", 0
str5 BYTE "排序之后的数组：", 0
str6 BYTE "请输入你要查找的数据: ", 0
str7 BYTE "该数据在数组中的索引（10进制）: ", 0
str8 BYTE "没有找到你要的数据！", 0
str9 BYTE "该数据在数组中的索引（2进制）:", 0
.code
main PROC
CALL recvArraySize
MOV arrSizeByUserInput, EAX
mov esi, offset arr
mov ecx, arrSizeByUserInput
CALL recvArrayData

INVOKE sortArray, ADDR arr, arrSizeByUserInput
INVOKE searchIntInArrayIndex, ADDR arr, arrSizeByUserInput

INVOKE ExitProcess, 0
main ENDP

searchIntInArrayIndex PROC arrAddr : DWORD, arrLength : DWORD
;  sub esp, 33
mov edx, offset str6
call WriteString
call ReadInt

mov esi, arrAddr
mov ecx, arrLength
mov edi, 0

; 找索引L1
L1 : cmp eax, [esi + edi]
je Found
add edi, 4
loop L1
; ecx = 0, 没有找到
jecxz NotFound

Found :
mov edx, offset str7
call WriteString

mov edx, 0; edx:eax  除数放在eax
mov eax, edi
mov ebx, 4
div ebx
call WriteInt

; 二进制
mov edx, offset str9
call crlf
call WriteString

; 4  cf = 0
; 0000 0000 0000 0000 0000 0000 0000 0100
; arrIndexBinary

mov ecx, 32
mov esi, offset arrIndexBinary

L7 : SHL eax, 1
mov byte ptr[esi], '1'
jc L8
mov byte ptr[esi], '0'

L8 :
    add esi, 1
    loop L7

    mov edx, offset arrIndexBinary
    call WriteString
    

    ret

    NotFound :
mov edx, offset str8
call WriteString

ret
searchIntInArrayIndex ENDP

sortArray PROC arrAddr : DWORD, arrLength : DWORD
mov esi, arrAddr
mov ecx, arrLength
dec ecx
L3 :
push ecx
mov edi, 0

L2 : mov eax, [esi + edi * type DWORD]
cmp eax, [esi + edi * type DWORD + 4]
jle L1
; xchg交换
xchg eax, [esi + edi * type DWORD + 4]
mov[esi + edi * type DWORD], eax

L1 : inc edi
loop L2
pop ecx
loop L3

mov edx, offset str5
call WriteString
call crlf

mov esi, arrAddr
mov ecx, arrLength
mov edi, 0

L4: mov eax, [esi + edi * 4]
call WriteInt
call crlf
inc edi
loop L4

ret
sortArray ENDP

recvArraySize PROC
mov edx, offset str1
call WriteString
call ReadInt
cmp eax, 200
JA L1
ret
L1 : mov edx, offset str2
call WriteString
EXIT
recvArraySize ENDP

recvArrayData PROC USES ESI ECX
mov edx, offset str3
L1 : call WriteString
xor eax, eax

call ReadInt
mov[esi], eax
add esi, type DWORD
loop L1

RET
recvArrayData ENDP

end main